7 kyu

input: "How can mirrors be real if our eyes aren't real" output: "How Can Mirrors Be Real If Our Eyes Aren't Real"

assert to_upper_case("How can mirrors be real if our eyes aren't real") == "How Can Mirrors Be Real If Our Eyes Aren't Real")

6 kyu

Создайте функцию, которая принимает строку и разделяет ее на последовательность букв.

Массив будет отформатирован так:

[['J','L','L','M']
    ,['u','i','i','a']
    ,['s','v','f','n']
    ,['t','e','e','']]
Функция должна разделять каждое слово на отдельные буквы, при этом буквы первого слова в предложении должны находиться в 0-м индексе каждого массива 2-го измерения и так далее.

Более короткие слова будут иметь пустую строку на месте, как только слово уже будет нанесено на карту. (См. последний элемент в последней части массива.)

Примеры:

sep_str("Just Live Life Man")
# => [['J','L','L','M'],
# => ['u','i','i','a'],
# => ['s','v','f','n'],
# => ['t','e','e','']]);
sep_str("The Mitochondria is the powerhouse of the cell")
# => [ [ 'T', 'M', 'i', 't', 'p', 'o', 't', 'c' ],
# => [ 'h', 'i', 's', 'h', 'o', 'f', 'h', 'e' ],
# => [ 'e', 't', '', 'e', 'w', '', 'e', 'l' ],
# => [ '', 'o', '', '', 'e', '', '', 'l' ],
# => [ '', 'c', '', '', 'r', '', '', '' ],
# => [ '', 'h', '', '', 'h', '', '', '' ],
# => [ '', 'o', '', '', 'o', '', '', '' ],
# => [ '', 'n', '', '', 'u', '', '', '' ],
# => [ '', 'd', '', '', 's', '', '', '' ],
# => [ '', 'r', '', '', 'e', '', '', '' ],
# => [ '', 'i', '', '', '', '', '', '' ],
# => [ '', 'a', '', '', '', '', '', '' ]]
assert sep_str("Just Live Life Man")== [['J','L','L','M'],
                                       ['u','i','i','a'],
                                       ['s','v','f','n'],
                                       ['t','e','e','']]
        
assert sep_str("The Mitochondria is the powerhouse of the cell") ==
                                    [[ 'T', 'M', 'i', 't', 'p', 'o', 't', 'c' ],
                                    [ 'h', 'i', 's', 'h', 'o', 'f', 'h', 'e' ],
                                    [ 'e', 't', '', 'e', 'w', '', 'e', 'l' ],
                                    [ '', 'o', '', '', 'e', '', '', 'l' ],
                                    [ '', 'c', '', '', 'r', '', '', '' ],
                                    [ '', 'h', '', '', 'h', '', '', '' ],
                                    [ '', 'o', '', '', 'o', '', '', '' ],
                                    [ '', 'n', '', '', 'u', '', '', '' ],
                                    [ '', 'd', '', '', 's', '', '', '' ],
                                    [ '', 'r', '', '', 'e', '', '', '' ],
                                    [ '', 'i', '', '', '', '', '', '' ],
                                    [ '', 'a', '', '', '', '', '', '' ]]    
5 kyu

Как в АНБ отличить экстраверта от интроверта? Va gur ryringbef, gur rkgebireg ybbxf ng gur BGURE thl'f ​​fubrf.

Я нашел эту шутку в USENET, но изюминка перепутана. Может, расшифруете? Согласно Википедии, ROT13 (http://en.wikipedia.org/wiki/ROT13) часто используется для запутывания шуток в USENET.

Подсказка: в этом задании вы должны только заменять символы. Без пробелов, знаков препинания, цифр и т.

Примеры тестов:

"EBG13 rknzcyr." -->
"ROT13 example."

"This is my first ROT13 excercise!" -->
"Guvf vf zl svefg EBG13 rkprepvfr!"




8 kyu
У меня есть кошка и собака.

Я завёл их одновременно с котенком/щенком. Это было humanYears много лет назад.

Теперь верните их соответствующие возрасты как [humanYears, catYears, dogYears]

ПРИМЕЧАНИЯ:

HumanYears >= 1

HumanYears - только целые числа

Кошачьи годы

15 - кошачьи годы для первого года

+9 - кошачьи годы на второй год

+4 - кошачьи годы за каждый последующий год

Собачьи годы

15 - собачьи годы за первый год

+9 - собачьи годы на второй год

+5 - собачьи годы за каждый последующий год

assert human_years_cat_years_dog_years(1) == [1,15,15]
assert human_years_cat_years_dog_years(2) == [2,24,24]
assert human_years_cat_years_dog_years(10) == [10,56,64]
7 kyu
У вас есть компас с 8 направлениями.

Вы получаете направление, в котором вы находитесь facing(одно из 8 направлений: N, NE, E, SE, S, SW, W, NW) и определенный градус turn(кратное 45, между -1080 и 1080); положительный означает по часовой стрелке, а отрицательный означает против часовой стрелки.

Вернитесь в том направлении, в котором вы столкнетесь после поворота.

Примеры

new_direction("S", 180) --> "N"

new_direction("SE", -45) --> "E"

new_direction("W", 495) --> "NE"

assert direction("S", 180) == "N"
assert direction("SE", -45) == "E"
assert direction("W", 495) == "NE"
6 kyu
Шифры Цезаря являются одной из самых основных форм шифрования. Он состоит из сообщения и ключа и сдвигает буквы сообщения на значение ключа.

Подробнее об этом читайте здесь: https://en.wikipedia.org/wiki/Caesar_cipher

Ваша задача — создать функцию-шифровальщик, которая принимает 2 аргумента — ключ и сообщение — и возвращает зашифрованное сообщение.

Удостоверьтесь, что вы меняете только буквы и следите за тем, чтобы регистры букв оставались одинаковыми. Все знаки препинания, цифры, пробелы и т. д. должны оставаться прежними.

Также помните о ключах больше 26 и меньше -26. В алфавите всего 26 букв!

Примеры

Сообщение 'Caesar Cipher'и ключ 1 -> 'Dbftbs Djqifs'.

Сообщение 'Caesar Cipher'и ключ -1 -> 'Bzdrzq Bhogdq'

assert encryptor(13, '') == ''
assert encryptor(13, 'Caesar Cipher') == 'Pnrfne Pvcure'
assert encryptor(-5, 'Hello World!') == 'Czggj Rjmgy!'
assert encryptor(27, 'Whoopi Goldberg') == 'Xippqj Hpmecfsh'